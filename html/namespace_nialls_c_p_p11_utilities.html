<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Niall&#39;s C++ 11 Utilities: NiallsCPP11Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Niall&#39;s C++ 11 Utilities
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NiallsCPP11Utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Where Niall's useful C++ 11 utilities live.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nialls_c_p_p11_utilities_1_1membuf.html">membuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a byte buffer processing std::streambuf.  <a href="struct_nialls_c_p_p11_utilities_1_1membuf.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nialls_c_p_p11_utilities_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator which allocates aligned memory.  <a href="class_nialls_c_p_p11_utilities_1_1aligned__allocator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nialls_c_p_p11_utilities_1_1_static_type_registry.html">StaticTypeRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterable, statically stored registry of items associated with a type.  <a href="struct_nialls_c_p_p11_utilities_1_1_static_type_registry.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html">MappedFileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about mapped files in the process.  <a href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nialls_c_p_p11_utilities_1_1_symbol_type.html">SymbolType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type potentially containing other types.  <a href="struct_nialls_c_p_p11_utilities_1_1_symbol_type.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nialls_c_p_p11_utilities_1_1_symbol_demangle.html">SymbolDemangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds state for a symbol demangle session.  <a href="class_nialls_c_p_p11_utilities_1_1_symbol_demangle.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af9b33658f9f7a0da430ebfef439ab298"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map<br class="typebreak"/>
&lt; std::string, const <br class="typebreak"/>
<a class="el" href="struct_nialls_c_p_p11_utilities_1_1_symbol_type.html">SymbolType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#af9b33658f9f7a0da430ebfef439ab298">SymbolTypeDict</a></td></tr>
<tr class="memdesc:af9b33658f9f7a0da430ebfef439ab298"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary of known symbol types. Used to store types across mangles/demangles.  <a href="#af9b33658f9f7a0da430ebfef439ab298"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a78f1e6f126ba868dfd6095e2e6b975c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7">allocator_alignment</a> { <br/>
&#160;&#160;<a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7ac0a6117316b51e064856205a59df98e4">Default</a> =  sizeof(void*), 
<a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7addd78bd451e3b8ef11296eda02beb232">SSE</a> =  16, 
<a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7ad28a86fc966f7b12225712eb8d1adb6d">M128</a> =  16, 
<a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7adbf2343aecdf571789961e2db1e0f345">AVX</a> =  32, 
<br/>
&#160;&#160;<a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7af628415fe9d4831b8b331fc28873f91f">M256</a> =  32
<br/>
 }</td></tr>
<tr class="memdesc:a78f1e6f126ba868dfd6095e2e6b975c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some preset alignment values for convenience.  <a href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7">More...</a><br/></td></tr>
<tr class="memitem:acc9e34ac457a82a88ad4bc675a1de73a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#acc9e34ac457a82a88ad4bc675a1de73a">SymbolTypeType</a> </td></tr>
<tr class="memdesc:acc9e34ac457a82a88ad4bc675a1de73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a symbol type.  <a href="namespace_nialls_c_p_p11_utilities.html#acc9e34ac457a82a88ad4bc675a1de73a">More...</a><br/></td></tr>
<tr class="memitem:a60b4b88adf0fb9327bf4cd9c5e31bca3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a60b4b88adf0fb9327bf4cd9c5e31bca3">SymbolTypeQualifier</a> </td></tr>
<tr class="memdesc:a60b4b88adf0fb9327bf4cd9c5e31bca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The qualifiers of a symbol type.  <a href="namespace_nialls_c_p_p11_utilities.html#a60b4b88adf0fb9327bf4cd9c5e31bca3">More...</a><br/></td></tr>
<tr class="memitem:ab69e44affbbb19e5dc37e5f6e71f20d1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#ab69e44affbbb19e5dc37e5f6e71f20d1">SymbolTypeStorage</a> </td></tr>
<tr class="memdesc:ab69e44affbbb19e5dc37e5f6e71f20d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The storage class of a symbol type.  <a href="namespace_nialls_c_p_p11_utilities.html#ab69e44affbbb19e5dc37e5f6e71f20d1">More...</a><br/></td></tr>
<tr class="memitem:af5700ea6f27a750699705a9c2b774262"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#af5700ea6f27a750699705a9c2b774262">SymbolTypeOperator</a> </td></tr>
<tr class="memdesc:af5700ea6f27a750699705a9c2b774262"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ operator type.  <a href="namespace_nialls_c_p_p11_utilities.html#af5700ea6f27a750699705a9c2b774262">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a692689edd5864b5912e568dc714b3b1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a692689edd5864b5912e568dc714b3b1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a692689edd5864b5912e568dc714b3b1c">is_nullptr</a> (T v) noexcept</td></tr>
<tr class="memdesc:a692689edd5864b5912e568dc714b3b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time safe detector of if <em>v</em> is nullptr (can cope with non-pointer convertibles)  <a href="#a692689edd5864b5912e568dc714b3b1c"></a><br/></td></tr>
<tr class="memitem:a4b0a143d1ff6792ff1e21f24e8de3457"><td class="memTemplParams" colspan="2">template&lt;typename callable &gt; </td></tr>
<tr class="memitem:a4b0a143d1ff6792ff1e21f24e8de3457"><td class="memTemplItemLeft" align="right" valign="top">UndoerImpl&lt; callable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a4b0a143d1ff6792ff1e21f24e8de3457">Undoer</a> (callable c)</td></tr>
<tr class="memdesc:a4b0a143d1ff6792ff1e21f24e8de3457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alexandrescu style rollbacks, a la C++ 11.  <a href="#a4b0a143d1ff6792ff1e21f24e8de3457"></a><br/></td></tr>
<tr class="memitem:abbba81f759ed968d4766a454af0e77e5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abbba81f759ed968d4766a454af0e77e5"><td class="memTemplItemLeft" align="right" valign="top">TextDumpImpl&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#abbba81f759ed968d4766a454af0e77e5">TextDump</a> (const T &amp;_inst)</td></tr>
<tr class="memdesc:abbba81f759ed968d4766a454af0e77e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A textual dumper of types.  <a href="#abbba81f759ed968d4766a454af0e77e5"></a><br/></td></tr>
<tr class="memitem:ae17b921a0f1b42285287c5b128240f9d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae17b921a0f1b42285287c5b128240f9d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#ae17b921a0f1b42285287c5b128240f9d">operator&lt;&lt;</a> (std::ostream &amp;s, const TextDumpImpl&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ae17b921a0f1b42285287c5b128240f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stream overloader for TextDump.  <a href="#ae17b921a0f1b42285287c5b128240f9d"></a><br/></td></tr>
<tr class="memitem:a965f0292f7637ed4ebc7fd80868cfa32"><td class="memTemplParams" colspan="2">template&lt;class typeregistry &gt; </td></tr>
<tr class="memitem:a965f0292f7637ed4ebc7fd80868cfa32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a965f0292f7637ed4ebc7fd80868cfa32">RegisterData</a> (const typename Impl::RegisterDataImpl&lt; typeregistry &gt;::type &amp;v)</td></tr>
<tr class="memdesc:a965f0292f7637ed4ebc7fd80868cfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a piece of data with the specified type registry.  <a href="#a965f0292f7637ed4ebc7fd80868cfa32"></a><br/></td></tr>
<tr class="memitem:a143d79eb9062a1f4f0daa5128d42d29b"><td class="memTemplParams" colspan="2">template&lt;class typeregistry &gt; </td></tr>
<tr class="memitem:a143d79eb9062a1f4f0daa5128d42d29b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a143d79eb9062a1f4f0daa5128d42d29b">RegisterData</a> (typename Impl::RegisterDataImpl&lt; typeregistry &gt;::type &amp;&amp;v)</td></tr>
<tr class="memdesc:a143d79eb9062a1f4f0daa5128d42d29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a piece of data with the specified type registry.  <a href="#a143d79eb9062a1f4f0daa5128d42d29b"></a><br/></td></tr>
<tr class="memitem:ab98fd771b551337d720d5d58cbde7cde"><td class="memTemplParams" colspan="2">template&lt;class typeregistry &gt; </td></tr>
<tr class="memitem:ab98fd771b551337d720d5d58cbde7cde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#ab98fd771b551337d720d5d58cbde7cde">UnregisterData</a> (const typename Impl::UnregisterDataImpl&lt; typeregistry &gt;::type &amp;v)</td></tr>
<tr class="memdesc:ab98fd771b551337d720d5d58cbde7cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a piece of data with the specified type registry.  <a href="#ab98fd771b551337d720d5d58cbde7cde"></a><br/></td></tr>
<tr class="memitem:a8fccad514b7b090e9f144752792001eb"><td class="memTemplParams" colspan="2">template&lt;class _typeregistry , class _type &gt; </td></tr>
<tr class="memitem:a8fccad514b7b090e9f144752792001eb"><td class="memTemplItemLeft" align="right" valign="top">Impl::DataRegistration<br class="typebreak"/>
&lt; _typeregistry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a8fccad514b7b090e9f144752792001eb">AutoDataRegistration</a> (_type &amp;&amp;c)</td></tr>
<tr class="memdesc:a8fccad514b7b090e9f144752792001eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto registers a data item with a type registry. Typically used at static init/deinit time.  <a href="#a8fccad514b7b090e9f144752792001eb"></a><br/></td></tr>
<tr class="memitem:a11f7d64eb51d888016a4f3c345031930"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a11f7d64eb51d888016a4f3c345031930">operator&lt;&lt;</a> (std::ostream &amp;s, const TextDumpImpl&lt; std::map&lt; size_t, <a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html">MappedFileInfo</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a11f7d64eb51d888016a4f3c345031930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Text dumps a std::map&lt;size_t, MappedFileInfo&gt;  <a href="#a11f7d64eb51d888016a4f3c345031930"></a><br/></td></tr>
<tr class="memitem:a9e49d46a2c01335da95e0ad634091728"><td class="memTemplParams" colspan="2">template&lt;class R , class... Pars&gt; </td></tr>
<tr class="memitem:a9e49d46a2c01335da95e0ad634091728"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; size_t, <br class="typebreak"/>
<a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html">MappedFileInfo</a> &gt;<br class="typebreak"/>
::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a9e49d46a2c01335da95e0ad634091728">FromCodePoint</a> (const std::map&lt; size_t, <a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html">MappedFileInfo</a> &gt; &amp;list, R(*codepoint)(Pars...))</td></tr>
<tr class="memdesc:a9e49d46a2c01335da95e0ad634091728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html" title="Information about mapped files in the process.">MappedFileInfo</a> containing code point <em>codepoint</em>, if any.  <a href="#a9e49d46a2c01335da95e0ad634091728"></a><br/></td></tr>
<tr class="memitem:a21dcaefb5e899dc8c3acb28344c8991d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a21dcaefb5e899dc8c3acb28344c8991d">Demangle</a> (const std::string &amp;mangled, <a class="el" href="class_nialls_c_p_p11_utilities_1_1_symbol_demangle.html">SymbolDemangle</a> &amp;demangler)</td></tr>
<tr class="memdesc:a21dcaefb5e899dc8c3acb28344c8991d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload which demangles a single mangled symbol, throwing an exception if it failed. Use the class if you're demangling more than one symbol.  <a href="#a21dcaefb5e899dc8c3acb28344c8991d"></a><br/></td></tr>
<tr class="memitem:ab098ff5e761c2d985be944a37bb70272"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#ab098ff5e761c2d985be944a37bb70272">Demangle</a> (const std::string &amp;mangled)</td></tr>
<tr class="memdesc:ab098ff5e761c2d985be944a37bb70272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload which demangles a single mangled symbol, throwing an exception if it failed. Use the class if you're demangling more than one symbol.  <a href="#ab098ff5e761c2d985be944a37bb70272"></a><br/></td></tr>
<tr class="memitem:a41b17bda0d6e63318f8bbae62dde58cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#a41b17bda0d6e63318f8bbae62dde58cc">Demangle</a> (const std::string &amp;mangled, std::nothrow_t, <a class="el" href="class_nialls_c_p_p11_utilities_1_1_symbol_demangle.html">SymbolDemangle</a> &amp;demangler)</td></tr>
<tr class="memdesc:a41b17bda0d6e63318f8bbae62dde58cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload which demangles a single mangled symbol, returning any error message if it failed. Use the class if you're demangling more than one symbol.  <a href="#a41b17bda0d6e63318f8bbae62dde58cc"></a><br/></td></tr>
<tr class="memitem:acbdf8c0613ff1367c1ce3019eb85c9de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nialls_c_p_p11_utilities.html#acbdf8c0613ff1367c1ce3019eb85c9de">Demangle</a> (const std::string &amp;mangled, std::nothrow_t nt)</td></tr>
<tr class="memdesc:acbdf8c0613ff1367c1ce3019eb85c9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload which demangles a single mangled symbol, returning any error message if it failed. Use the class if you're demangling more than one symbol.  <a href="#acbdf8c0613ff1367c1ce3019eb85c9de"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Where Niall's useful C++ 11 utilities live. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="af9b33658f9f7a0da430ebfef439ab298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;std::string, const <a class="el" href="struct_nialls_c_p_p11_utilities_1_1_symbol_type.html">SymbolType</a>&gt; <a class="el" href="namespace_nialls_c_p_p11_utilities.html#af9b33658f9f7a0da430ebfef439ab298">NiallsCPP11Utilities::SymbolTypeDict</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dictionary of known symbol types. Used to store types across mangles/demangles. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a78f1e6f126ba868dfd6095e2e6b975c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_nialls_c_p_p11_utilities.html#a78f1e6f126ba868dfd6095e2e6b975c7">NiallsCPP11Utilities::allocator_alignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some preset alignment values for convenience. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a78f1e6f126ba868dfd6095e2e6b975c7ac0a6117316b51e064856205a59df98e4"></a>Default</em>&nbsp;</td><td>
<p>The default alignment on this machine. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a78f1e6f126ba868dfd6095e2e6b975c7addd78bd451e3b8ef11296eda02beb232"></a>SSE</em>&nbsp;</td><td>
<p>The alignment for SSE. Better to use M128 for NEON et al support. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a78f1e6f126ba868dfd6095e2e6b975c7ad28a86fc966f7b12225712eb8d1adb6d"></a>M128</em>&nbsp;</td><td>
<p>The alignment for a 128 bit vector. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a78f1e6f126ba868dfd6095e2e6b975c7adbf2343aecdf571789961e2db1e0f345"></a>AVX</em>&nbsp;</td><td>
<p>The alignment for AVX. Better to use M256 for NEON et al support. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a78f1e6f126ba868dfd6095e2e6b975c7af628415fe9d4831b8b331fc28873f91f"></a>M256</em>&nbsp;</td><td>
<p>The alignment for a 256 bit vector. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af5700ea6f27a750699705a9c2b774262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_nialls_c_p_p11_utilities.html#af5700ea6f27a750699705a9c2b774262">NiallsCPP11Utilities::SymbolTypeOperator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ operator type. </p>

</div>
</div>
<a class="anchor" id="a60b4b88adf0fb9327bf4cd9c5e31bca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_nialls_c_p_p11_utilities.html#a60b4b88adf0fb9327bf4cd9c5e31bca3">NiallsCPP11Utilities::SymbolTypeQualifier</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The qualifiers of a symbol type. </p>

</div>
</div>
<a class="anchor" id="ab69e44affbbb19e5dc37e5f6e71f20d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_nialls_c_p_p11_utilities.html#ab69e44affbbb19e5dc37e5f6e71f20d1">NiallsCPP11Utilities::SymbolTypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The storage class of a symbol type. </p>

</div>
</div>
<a class="anchor" id="acc9e34ac457a82a88ad4bc675a1de73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_nialls_c_p_p11_utilities.html#acc9e34ac457a82a88ad4bc675a1de73a">NiallsCPP11Utilities::SymbolTypeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a symbol type. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8fccad514b7b090e9f144752792001eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _typeregistry , class _type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Impl::DataRegistration&lt;_typeregistry&gt; NiallsCPP11Utilities::AutoDataRegistration </td>
          <td>(</td>
          <td class="paramtype">_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto registers a data item with a type registry. Typically used at static init/deinit time. </p>
<p>Per DLL object: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> StaticTypeRegistry&lt;Foo, std::unique_ptr&lt;Foo&gt;(*)()&gt; MakeablesRegistry;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">auto</span> reg=AutoDataRegistration&lt;MakeablesRegistry&gt;(&amp;Goo::Make);</div>
</div><!-- fragment --><p> This registers the Goo::Make callable with the registry MakeablesRegistry during DLL load. It also unregisters during DLL unload.</p>
<p>You now have a registry of static Make() methods associated with type MakeablesRegistry. To iterate: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> n : StaticTypeRegistry&lt;MakeablesRegistry&gt;())</div>
<div class="line">   ...</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a21dcaefb5e899dc8c3acb28344c8991d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string NiallsCPP11Utilities::Demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mangled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolDemangle &amp;&#160;</td>
          <td class="paramname"><em>demangler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload which demangles a single mangled symbol, throwing an exception if it failed. Use the class if you're demangling more than one symbol. </p>

</div>
</div>
<a class="anchor" id="ab098ff5e761c2d985be944a37bb70272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string NiallsCPP11Utilities::Demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mangled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload which demangles a single mangled symbol, throwing an exception if it failed. Use the class if you're demangling more than one symbol. </p>

</div>
</div>
<a class="anchor" id="a41b17bda0d6e63318f8bbae62dde58cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; NiallsCPP11Utilities::Demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mangled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nothrow_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolDemangle &amp;&#160;</td>
          <td class="paramname"><em>demangler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload which demangles a single mangled symbol, returning any error message if it failed. Use the class if you're demangling more than one symbol. </p>

</div>
</div>
<a class="anchor" id="acbdf8c0613ff1367c1ce3019eb85c9de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; NiallsCPP11Utilities::Demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mangled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nothrow_t&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload which demangles a single mangled symbol, returning any error message if it failed. Use the class if you're demangling more than one symbol. </p>

</div>
</div>
<a class="anchor" id="a9e49d46a2c01335da95e0ad634091728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class... Pars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;size_t, <a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html">MappedFileInfo</a>&gt;::const_iterator NiallsCPP11Utilities::FromCodePoint </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; size_t, MappedFileInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(*)(Pars...)&#160;</td>
          <td class="paramname"><em>codepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the <a class="el" href="struct_nialls_c_p_p11_utilities_1_1_mapped_file_info.html" title="Information about mapped files in the process.">MappedFileInfo</a> containing code point <em>codepoint</em>, if any. </p>

</div>
</div>
<a class="anchor" id="a692689edd5864b5912e568dc714b3b1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool NiallsCPP11Utilities::is_nullptr </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile-time safe detector of if <em>v</em> is nullptr (can cope with non-pointer convertibles) </p>

</div>
</div>
<a class="anchor" id="ae17b921a0f1b42285287c5b128240f9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; NiallsCPP11Utilities::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextDumpImpl&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default stream overloader for TextDump. </p>

</div>
</div>
<a class="anchor" id="a11f7d64eb51d888016a4f3c345031930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; NiallsCPP11Utilities::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextDumpImpl&lt; std::map&lt; size_t, MappedFileInfo &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Text dumps a std::map&lt;size_t, MappedFileInfo&gt; </p>

</div>
</div>
<a class="anchor" id="a965f0292f7637ed4ebc7fd80868cfa32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class typeregistry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NiallsCPP11Utilities::RegisterData </td>
          <td>(</td>
          <td class="paramtype">const typename Impl::RegisterDataImpl&lt; typeregistry &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a piece of data with the specified type registry. </p>

</div>
</div>
<a class="anchor" id="a143d79eb9062a1f4f0daa5128d42d29b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class typeregistry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NiallsCPP11Utilities::RegisterData </td>
          <td>(</td>
          <td class="paramtype">typename Impl::RegisterDataImpl&lt; typeregistry &gt;::type &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a piece of data with the specified type registry. </p>

</div>
</div>
<a class="anchor" id="abbba81f759ed968d4766a454af0e77e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TextDumpImpl&lt;T&gt; NiallsCPP11Utilities::TextDump </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A textual dumper of types. </p>
<p>Use this to signify that you wish to dump a textual representation of the given object instance to a std::ostream, like this: </p>
<div class="fragment"><div class="line">s &lt;&lt; <a class="code" href="namespace_nialls_c_p_p11_utilities.html#abbba81f759ed968d4766a454af0e77e5" title="A textual dumper of types.">TextDump</a>(obj) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>To add text dumpers for your particular type, overload operator&lt;&lt; as follows: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _registry, <span class="keyword">class</span> _type, <span class="keyword">class</span> _containertype&gt; <span class="keyword">inline</span> std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const TextDumpImpl&lt;StaticTypeRegistry&lt;_registry, _type, _containertype&gt;&gt; &amp;v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : *v.inst)</div>
<div class="line">        s &lt;&lt; <span class="stringliteral">&quot;* &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --><p>An alternative is to provide a textDump() method for your object like this: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::ostream &amp;textDump(std::ostream &amp;s) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4b0a143d1ff6792ff1e21f24e8de3457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UndoerImpl&lt;callable&gt; NiallsCPP11Utilities::Undoer </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alexandrescu style rollbacks, a la C++ 11. </p>
<p>Example of usage: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> resetpos=<a class="code" href="namespace_nialls_c_p_p11_utilities.html#a4b0a143d1ff6792ff1e21f24e8de3457" title="Alexandrescu style rollbacks, a la C++ 11.">Undoer</a>([&amp;s]() { s.seekg(0, std::ios::beg); });</div>
<div class="line">...</div>
<div class="line">resetpos.dismiss();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab98fd771b551337d720d5d58cbde7cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class typeregistry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NiallsCPP11Utilities::UnregisterData </td>
          <td>(</td>
          <td class="paramtype">const typename Impl::UnregisterDataImpl&lt; typeregistry &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters a piece of data with the specified type registry. </p>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer">(C) 2012 <a href="http://www.nedprod.com/">Niall Douglas</a></address>
</body>
</html>
